<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Codebeat.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Codebeat.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'
const Frequency = require('./frequency'),
Duration = require('./duration')

class Codebeat {
	/**
	* Creates an instance of Codebeat.
	* @constructor
	* @param {Object} props - Initialize with tempo, timeSig, instrument, notes, and loop properties.
	*/
	constructor(props) {
		this.tempo      = props.tempo || 60
		this.timeSig    = props.timeSig || '4/4'
		this.instrument = props.instrument || 'sine'
		this.notes      = props.notes || ''
		this.willLoop     = props.loop || false
    	this.create_context()
		this.parse_notes()
		this.get_bpm()
		this.set_play_index(0)
	}

	/**
     * Update current properties.
	 * @param {Object} props - Update the tempo, timeSig, instrument, notes, and/or loop properties.
     */
	update(props) {
		Object.keys(props).forEach(key => {
			this[key] = props[key]
		})
		this.set_play_index(0)
		this.parse_notes()
		this.get_bpm()
	}

	/**
	* Calculate duration in seconds.
	* @param {number} duration - Note duration relative to one measure.
	* @return {number} Time of duration in seconds.
	*/
	to_time(duration) {
		return (duration * this.beatsPerMeasure * 60) / this.tempo
	}

	/**
	* Get the number of beats per measure based on the timeSig property numerator.
	* Called on initialization or update().
	*/
	get_bpm() {
		this.beatsPerMeasure = parseInt(this.timeSig, 10)
	}

	/**
	* Set the position to begin at on play(), etc.
	* @param {number} index - Current play index.
	*/
	set_play_index(index) {
		this.playIndex = index
	}

	/**
	* Open an audio context.
	*/
	create_context() {
		this.context = new (window.AudioContext || window.webkitAudioContext)()
	}

	/**
	* Given the name of a note pitch (e.g. f#4), get its equivalent frequency in Hertz.
	* @param {string} name - Pitch name.
	*/
	get_frequency(name) {
		return Frequency[name]
	}

	/**
	* Given the name of a note duration (e.g. h-dot), get its equivalent length relative to one measure.
	* @param {string} name - Duration name.
	*/
	get_duration(name) {
		return Duration[name]
	}

	/**
	* Transform the 'notes' property into a two-dimensional array of notes, e.g. [['h', 'f3'], ['q', 'e3']].
	*/
	parse_notes() {
		const parse = n => { return n.trim().split(' ') },
		notesArray = this.notes.split(',')
		this.notesParsed = notesArray.map(note => parse(note))
	}

	/**
	* Output audio through an audio context, which closes after the last oscillator node ends, or on stop().
	*/
	play() {
		const oscillator = this.context.createOscillator(),
		note = this.notesParsed[this.playIndex],
		stopTime = this.to_time(this.get_duration(note[0])),
		pitch = this.get_frequency(note[1])

		oscillator.connect(this.context.destination)
		oscillator.type = this.instrument
		oscillator.frequency.value = pitch
		oscillator.start(0)
		oscillator.stop(this.context.currentTime + stopTime)

		oscillator.onended = () => {
			if (this.playIndex &lt; this.notesParsed.length - 1) {
				this.playIndex += 1
				this.play()
			} else this.ended()
		}
	}

	/**
	* Play through a composition in reverse.
	*/
	playReverse() {
		this.notesParsed.reverse()
		this.play()
	}

	/**
	* Repeat audio until stop() is called.
	*/
	playLoop() {
		this.willLoop = true
		this.play()
	}

	/**
	* Repeat audio in reverse until stop() is called.
	*/
	playReverseLoop() {
		this.willLoop = true
		this.playReverse()
	}

	/**
	* End looping and call ended().
	*/
	stop() {
		this.willLoop = false
		this.ended()
	}

	/**
	* End current audio loop.
	*/
	ended() {
		this.context.close().then(() => {
			this.set_play_index(0)
			this.create_context()
			this.willLoop ?
				this.play() :
				this.parse_notes()
		})
	}

	/**
	* Get a summary of note pitch names from the composition.
	* @return {Array} Sorted note names at first octave.
	*/
	brief() {
		//array of notes to frequencies
		let freq = this.notesParsed.map(note => this.get_frequency(note[1])),
		//find first octave of each note
		origin = freq.map(f => this.originFrequency(f)),
		//eliminate duplicates
		notes = origin.filter((note, i) => i === origin.indexOf(note))
		//lowest to highest by frequency
	  	notes.sort()
		//frequencies to names
		let names = notes.map(note => this.noteName(note))
		//return an array of all note pitch names that appear in the melody
		return names.filter(name => name &amp;&amp; name !== 'rest')
	}

	/**
	* Get the length of the composition.
	* @return {number} Total time of composition in seconds.
	*/
	time() {
		let time = 0
		if (this.notes) {
			this.notesParsed.forEach(note => {
				time += this.to_time(this.get_duration(note[0]))
			})
		}
		return time
	}

	/**
	* Get the same note in the first octave.
	* @param {number} frequency - Frequency of a note.
	* @return {number} Frequency of the same note in the first octave.
	*/
	originFrequency(freq) {
		let i = 0
		//notes in the first octave fall below 56Hz
		while (freq >= 56) {
			freq /= Math.pow(2, i)
			i += 1
		}
		return freq
	}

	/**
	* Get the name of a note from its frequency.
	* @param {number} frequency - Frequency of a note.
	* @return {number} Name of the note.
	*/
	noteName(freq) {
		for (var key in Frequency) {
		    if (Frequency[key] === freq) {
				return key
		    }
		}
	}

	/**
	* Get the number of times each note appears in the composition.
	* @return {Object} Total count of each note.
	*/
	countNotes() {
		let notes = this.notesParsed,
		count = {}
		for(let note of notes) {
			if(!count[note[1]]) {
				count[note[1]] = 0
			}
			count[note[1]] += 1
		}
		return count
	}
/*
	//METHODS INVOLVING DATA
	keyData() {
		return ['a', 'b', 'c', 'd', 'e', 'f', 'g']
	}

	queryKey() {
		let compNotes = this.brief(),
		data = this.keyData(),
		isKey = false
		for (let note in compNotes) {
			isKey = data.indexOf(note) ? true : false
		}
		if(isKey) {
			return 'c major'
		}
		else return false
	}
*/
}

module.exports = Codebeat
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Codebeat.html">Codebeat</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Feb 01 2017 15:30:38 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
